# 🧠 一、隐式空闲列表（Implicit Free List）

### ✅ 原理

* 整个堆是一个线性结构，每个块（block）由头部（size + 状态）和数据区组成。
* 分配时从头遍历整个内存块，找第一个适合的空闲块。
* 释放时将块标记为空闲，同时可尝试与相邻块合并（coalescing）。
* 没有额外的空闲链表，依靠遍历。

### 📦 内存结构图（按块顺序排列）：

```
[HDR|DATA     ][HDR|     ][HDR|DATA][HDR|     ][HDR|DATA]
 ^             ^           ^         ^           ^
 used         free        used      free        used
```

* 每个块包含一个头部（HDR），记录大小和是否空闲。
* 所有块在内存中顺序排列。
* 没有额外的链表，**遍历整个内存块查找空闲块**。

### 📌 操作流程：

* **分配：** 从头扫描，找到第一个够大的空闲块。
* **释放：** 直接标记为 free，可能尝试合并左右邻居。

### ✅ 优点

* 实现简单。
* 所有块按顺序排列，便于合并和遍历。

### ❌ 缺点

* 查找空闲块需要线性遍历，效率低（尤其在碎片严重时）。
* 每次都从头开始查找。
* 分配效率和碎片管理能力较弱。

### ✅ 适用场景

* 教学、入门实现。
* 小程序，分配压力不大。

---

# 🧠 二、显式空闲列表（Explicit Free List）

### ✅ 原理

* 使用一个链表专门管理“空闲块”，链表中的节点是空闲的内存块。
* 分配时只遍历空闲链表，而不是整个堆。
* 每个空闲块内部保存 `next` 和 `prev` 指针。
* 释放后，将块插入到空闲链表并尝试合并。

### 📦 内存结构图：

```
堆中：
[HDR|DATA][HDR|N|P|      ][HDR|DATA][HDR|N|P|      ][HDR|DATA]
             ^  ^                          ^
         next  prev                     next of list

空闲链表：
 free_list_head -> Block2 <-> Block4
```

* 空闲块之间用 `next` 和 `prev` 指针链接成链表。
* 分配时只查链表，不遍历整个堆。
* 释放时插入链表，并尝试合并。

### 📌 操作流程：

* **分配：** 遍历空闲链表，找到适合的空闲块。
* **释放：** 插入空闲链表，尝试合并相邻空闲块。

### ✅ 优点

* 查找效率高于隐式列表（仅查空闲块）。
* 方便合并相邻空闲块。
* 空间碎片管理更灵活。

### ❌ 缺点

* 每个空闲块需额外维护链表指针，空间开销略大。
* 实现复杂度高于隐式空闲列表。

### ✅ 适用场景

* 中型程序或嵌入式系统，自定义内存池。
* 需要比隐式分配更好性能和控制的场合。

---

# 🧠 三、分离适应（Segregated Fits / Segregated Free Lists）

### ✅ 原理

* 将不同大小的空闲块按“类”划分，每类一个空闲链表（例如 0-32B，33-64B，...）。
* 分配时直接查找合适类的链表，不必遍历整个链表。
* 有的实现支持 *精确大小类*，有的使用 *对数分组*（Log2 size class）。

### 📦 多链表结构（按大小分类）：

```
bin_32  -> [HDR|32][HDR|32]
bin_64  -> [HDR|64]
bin_128 -> [HDR|128][HDR|128]
bin_256 -> ...
```

* 按照大小分成多个桶，每个桶一个链表。
* **快速定位：** 分配 64 字节就查 bin\_64。
* 支持合并、拆分块。

### 📌 操作流程：

* **分配：**

  * 找到对应大小的 bin；
  * 若 bin 空，找更大的；
  * 若找到，可能拆块使用。
* **释放：**

  * 插入相应大小的 bin；
  * 可能合并相邻块。

### ✅ 优点

* 分配速度快（常数级），减少遍历。
* 减少碎片：更容易匹配合适大小。
* 适合频繁分配/释放不同大小块的场景。

### ❌ 缺点

* 需要多个链表管理，内存管理代码更复杂。
* 类之间的边界可能产生内部碎片（例如需要33B，只有64B块）。

### ✅ 适用场景

* 高性能内存分配器，如 jemalloc、ptmalloc、tcmalloc 等。
* Web 服务器、游戏引擎、数据库等系统。

---

# 🧠 四、桶式分配器 / 固定大小分配（Fixed-size Bins / Slab）

### ✅ 原理

* 为特定大小（如 32B, 64B, 128B）建立固定大小的对象池。
* 每类大小一组空闲块（桶/bin/slab）。
* 每次分配固定大小块，释放后归还该桶。

### 📦 固定大小块的桶结构：

```
bin_32:
  [32B] -> [32B] -> [32B] -> NULL

bin_64:
  [64B] -> [64B] -> NULL
```

* 每种大小一个“桶”，每个桶是一个空闲链表。
* 分配和释放都为常数时间（O(1)）。
* 通常不合并、不拆分。

### 📌 操作流程：

* **分配：** 从目标 bin 的链表头 pop 一块；
* **释放：** push 回对应 bin。

### ✅ 优点

* 分配和释放都为常数时间，极快。
* 减少碎片（块大小统一）。
* 非常适合对象复用（池化技术）。

### ❌ 缺点

* 不适合分配任意大小（只能支持几个预定义的大小）。
* 类别大小不匹配时造成浪费（内部碎片）。

### ✅ 适用场景

* 嵌入式系统、小型对象池。
* 分配大量相同大小对象，如网络包、结构体池、游戏实体池。

---

# 📊 总结对比表

| 特性       | 隐式空闲列表 | 显式空闲列表   | 分离适应    | 桶式分配器      |
| -------- | ------ | -------- | ------- | ---------- |
| ✅ 查找速度   | 慢（线性）  | 中（遍历空闲链） | 快（分类定位） | 极快（O(1)）   |
| ✅ 合并空闲块  | 支持     | 支持       | 支持      | 不支持        |
| ✅ 内部碎片控制 | 差      | 中        | 好       | 差（大小固定）    |
| ✅ 外部碎片控制 | 差      | 中        | 好       | 极好         |
| ✅ 实现复杂度  | 简单     | 中等       | 较复杂     | 简单         |
| ✅ 支持任意大小 | 是      | 是        | 是       | 否（固定几个大小）  |
| ✅ 空间使用效率 | 一般     | 较好       | 较好      | 高（但浪费固定空间） |
| ✅ 最佳应用场景 | 教学、入门  | 中型分配器    | 高性能通用分配 | 高性能固定对象分配  |


# 🔚 四者视觉对比总结

| 类型     | 结构形状（ASCII）                                    | 描述              |               |      |         |            |
| ------ | ---------------------------------------------- | --------------- | ------------- | ---- | ------- | ---------- |
| 隐式空闲列表 | `[HDR][HDR][HDR]...`                           | 顺序排列，每块含状态      |               |      |         |            |
| 显式空闲列表 | \`\[HDR                                        | next            | prev]`↔`\[HDR | next | prev]\` | 空闲块之间用指针相连 |
| 分离适应   | `bin_32 -> [32B]->[32B]`, `bin_64 -> [64B]...` | 多个大小分类链表        |               |      |         |            |
| 桶式分配器  | `bin_N -> [N]->[N]->[N]`（固定 N）                 | 每类一堆等大块，超快 O(1) |               |      |         |            |

# 🚀 总结建议

| 使用场景            | 推荐技术         |
| --------------- | ------------ |
| 教学 / 学习 / 小型项目  | 隐式 / 显式空闲列表  |
| 嵌入式开发（带内存池）     | 显式空闲列表或桶式分配  |
| 分配对象大小较固定       | 桶式分配器        |
| 分配对象大小多变，追求效率   | 分离适应         |
| 需要高性能、低碎片、可扩展系统 | 分离适应（结合缓存友好） |


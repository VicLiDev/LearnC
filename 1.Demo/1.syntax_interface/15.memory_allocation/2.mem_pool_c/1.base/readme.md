# C 语言内存池框架和特性讲解

---

## 一、整体框架结构

1. **Slab 分配器设计**

   * 内存池维护一组预定义尺寸的 slab（内存块池），每个 slab 负责固定大小的块分配。
   * 支持 8 种固定尺寸（32、64、128、256、512、1024、2048、4096 字节）。
   * 申请时，根据请求大小选择最合适的 slab。
   * 如果请求大小超过所有 slab 的最大尺寸，则动态申请内存。

2. **Block 结构体管理每个分配块**

   * 记录实际分配的内存指针（`real_ptr`）。
   * 用户指针（`user_ptr`）在内存块的保护区域之后。
   * 记录分配大小和链表指针以管理 free list。
   * 维护调用栈信息，用于调试内存泄漏。

3. **保护机制（Guard Bytes）**

   * 每个分配的 buffer 前后各有固定大小的“保护字节”（16 字节）。
   * 用特定字节填充（0xAB），用于检测溢出或越界写。
   * 释放时校验保护字节是否被篡改，发现内存破坏报警。

4. **调用栈追踪**

   * 每次分配时捕获调用栈（最多10帧）。
   * 释放时或泄漏检测时打印调用栈信息，便于定位内存使用问题。

5. **线程安全**

   * 使用全局互斥锁保护 slab 数据结构和全局状态。
   * 所有接口（分配、释放、统计打印等）均加锁，确保多线程安全。

6. **活跃内存块跟踪**

   * 维护所有当前未释放的内存块指针数组，用于泄漏检测。
   * 释放时从该数组移除对应块，避免重复释放或非法释放。

---

## 二、核心功能和接口

* `mp_init()`：初始化 slab 结构，准备内存池使用。
* `mp_alloc(size_t size)`：分配内存，返回用户可用指针。
* `mp_free(void* ptr)`：释放内存，并进行保护区校验。
* `mp_dump_stats()`：打印 slab 使用统计信息（总数、在用数、空闲数）。
* `mp_dump_leaks()`：打印当前所有未释放的内存块，附带调用栈信息，方便调试内存泄漏。
* `mp_destroy()`：销毁内存池，释放所有资源，并自动打印统计和泄漏信息。

---

## 三、设计特性亮点

| 特性              | 说明                                    |
| --------------- | ------------------------------------- |
| **Slab 分配器**    | 减少内存碎片，提高小块内存分配效率。                    |
| **动态 fallback** | 超过 slab 最大块大小时，动态调用 malloc，保证灵活性。     |
| **保护字节机制**      | 边界保护，能检测缓冲区溢出错误。                      |
| **调用栈记录**       | 捕获并打印内存分配调用栈，帮助定位泄漏和错误。               |
| **线程安全**        | 通过互斥锁保护所有公共数据结构，多线程安全。                |
| **泄漏检测**        | 跟踪所有活动内存块，程序退出时打印未释放内存，辅助排查泄漏。        |
| **接口清晰**        | 初始化、分配、释放、统计、销毁，使用方便。                 |
| **无锁内部打印版本**    | 解决死锁风险，`mp_destroy` 内部调用无锁版本 dump 函数。 |

---

## 四、工作流程示例

1. 用户调用 `mp_alloc(100)`，内存池找到第一个足够大的 slab（128 bytes slab），

   * 如果 slab 有空闲块，直接返回；否则申请新内存块。
   * 在用户指针前后写入保护字节。
   * 记录调用栈，添加到活动块数组。

2. 用户使用完毕调用 `mp_free()`，

   * 内存池校验保护字节，检测是否溢出。
   * 从活动块数组中删除对应块。
   * 如果块属于 slab，将块放回 slab 空闲链表。否则释放内存。

3. 程序结束时调用 `mp_destroy()`，

   * 自动打印统计和泄漏信息（包括调用栈），
   * 释放所有 slab 和活动块资源。

---

## 五、总结

这个内存池结合了 **性能优化（slab 分配）**、**安全性（边界保护）** 和 **调试支持（调用栈
追踪和泄漏检测）**，非常适合需要 **灵活内存管理**、并且注重 **错误诊断和多线程安全** 的 C 项目。

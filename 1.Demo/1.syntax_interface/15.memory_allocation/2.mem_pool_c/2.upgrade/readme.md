这个 C 语言版本的内存池 Demo 是一个 **线程安全、可调试、带保护机制和统计分析的
slab 分配器实现**。相比之前的简单 demo，这个版本在 **架构完整性、调试能力、错误检测
和性能优化** 方面做了多个显著升级。

---

## ✅ 框架结构

项目结构如下：

```
.
├── main.c              // 测试入口（多线程模拟内存分配/释放）
├── mem_pool.c          // 内存池实现
├── mem_pool.h          // 内存池接口定义
├── Makefile            // 编译规则
```

---

## ✅ 核心模块说明

### 1. `mem_pool.h` — 接口定义

定义了以下 API：

```c
void* mem_pool_alloc(size_t size, const char* label);
void  mem_pool_free(void* ptr);
void  mem_pool_stats();
```

> ✅ 可通过 `label` 参数标记分配来源（如 "net", "db", "ui"），用于分布统计。

---

### 2. `mem_pool.c` — 实现细节

#### ✅ slab 分配策略

* 根据请求大小，向系统请求 chunk（大页），按需切分成块。
* 不同大小的块组织成多个 slab，每种大小独立管理。
* 使用 **链表池化**回收已释放内存块，提升再分配性能。

#### ✅ 内存保护

* 每块分配的前后加上 `guard` 值：`PROTECT_MAGIC` 和 `TAIL_MAGIC`。
* 在释放时验证，**检测越界写入**。

#### ✅ 线程安全

* 每个 slab 类型都有自己的锁。
* 分配器使用 **`pthread_mutex`** 保护内部结构。

#### ✅ 调试信息

* 每次分配记录调用栈（`backtrace()`）和分配时间。
* 释放时校验是否双重释放。
* 支持 **内存泄漏检测**：程序退出前输出所有未释放块信息。

#### ✅ 统计信息

* 每种 `label` 类型的内存申请统计总数、总字节数。
* 可调用 `mem_pool_stats()` 输出实时分布情况。

---

### 3. `main.c` — 测试模拟

* 启动多个线程模拟不同 label 的模块分配内存（"net"、"db"、"ui"）。
* 线程内随机申请和释放内存。
* 结束前打印内存使用统计。

---

## 🔼 相对于之前 demo 的升级点

| 功能          | 旧版 demo | 当前版本                       |
| ------------- | --------- | ------------------------------ |
| 任意大小支持  | ✅ 支持   | ✅ 支持                        |
| 线程安全      | 基本锁    | 每类 slab 独立锁，更细粒度     |
| slab 管理     | 简单回收  | slab 大小分层、结构清晰        |
| 调试支持      | ❌        | ✅ `backtrace` 调用栈追踪      |
| 内存保护      | ❌        | ✅ 分配前后保护区检测越界      |
| 内存泄漏检查  | ❌        | ✅ 打印泄漏及调用栈            |
| 内存分布统计  | ❌        | ✅ 按 label 统计实时分析       |
| 多线程测试    | ❌        | ✅ 模拟 UI/NET/DB 模块内存使用 |

---

## 🔚 总结

这个版本的内存池是一个功能较完整、调试和性能兼顾的内存分配器框架，适合嵌入中型服务进行内存管理追踪。它不仅优化了 slab 分配逻辑和内存重用，还能为你定位内存泄漏、双重释放、越界访问等常见错误，极大提升了代码健壮性。


GCC 提供了一系列**原子操作内建函数**，主要用于多线程编程中的**同步操作**和**内存
屏障**。以下是一些常用的类似函数：

---

## **1. 算术操作函数**
### **加法和减法**
| 函数名                             | 描述                                          |
|------------------------------------|-----------------------------------------------|
| `__sync_fetch_and_add(ptr, value)` | 将 `value` 加到 `*ptr` 上，返回操作前的值。   |
| `__sync_add_and_fetch(ptr, value)` | 将 `value` 加到 `*ptr` 上，返回操作后的值。   |
| `__sync_fetch_and_sub(ptr, value)` | 将 `value` 从 `*ptr` 中减去，返回操作前的值。 |
| `__sync_sub_and_fetch(ptr, value)` | 将 `value` 从 `*ptr` 中减去，返回操作后的值。 |

---

## **2. 位操作函数**
### **按位操作**
| 函数名                             | 描述                                                 |
|------------------------------------|------------------------------------------------------|
| `__sync_fetch_and_or(ptr, value)`  | 执行按位 OR 操作，`*ptr |= value`，返回操作前的值。  |
| `__sync_or_and_fetch(ptr, value)`  | 执行按位 OR 操作，`*ptr |= value`，返回操作后的值。  |
| `__sync_fetch_and_and(ptr, value)` | 执行按位 AND 操作，`*ptr &= value`，返回操作前的值。 |
| `__sync_and_and_fetch(ptr, value)` | 执行按位 AND 操作，`*ptr &= value`，返回操作后的值。 |
| `__sync_fetch_and_xor(ptr, value)` | 执行按位 XOR 操作，`*ptr ^= value`，返回操作前的值。 |
| `__sync_xor_and_fetch(ptr, value)` | 执行按位 XOR 操作，`*ptr ^= value`，返回操作后的值。 |

---

## **3. 比较与交换操作**
### **CAS (Compare-And-Swap)**
| 函数名                                              | 描述                                                                                          |
|-----------------------------------------------------|-----------------------------------------------------------------------------------------------|
| `__sync_bool_compare_and_swap(ptr, oldval, newval)` | 如果 `*ptr == oldval`，则将 `*ptr` 设置为 `newval`，返回 `true` 或 `false` 表示操作是否成功。 |
| `__sync_val_compare_and_swap(ptr, oldval, newval)`  | 如果 `*ptr == oldval`，则将 `*ptr` 设置为 `newval`，返回操作前的值（无论成功与否都返回旧值）。|

---

## **4. 内存屏障和锁操作**
### **内存屏障**
| 函数名                 | 描述                                                             |
|------------------------|------------------------------------------------------------------|
| `__sync_synchronize()` | 执行全局内存屏障，确保所有之前的内存操作完成后，才执行后续操作。 |

### **自旋锁操作**
| 函数名                                 | 描述                                                                    |
|----------------------------------------|-------------------------------------------------------------------------|
| `__sync_lock_test_and_set(ptr, value)` | 设置 `*ptr = value` 并返回旧值（常用于实现自旋锁）。                    |
| `__sync_lock_release(ptr)`             | 将 `*ptr` 设为 0（释放锁），通常与 `__sync_lock_test_and_set` 配合使用。|

---

## **5. C++11 新标准的原子操作函数 (推荐)**
现代 C++11 标准引入了更强大、更灵活的 `<atomic>` 库，推荐优先使用这些函数代替 GCC 的 `__sync_*` 系列。

示例：
```cpp
#include <atomic>
std::atomic<int> counter(0);

// 加法操作
counter.fetch_add(1, std::memory_order_relaxed);

// 比较并交换
int expected = 0;
counter.compare_exchange_strong(expected, 10);
```

---

## **6. 新版内置函数：__atomic 系列**
GCC 后续版本还引入了更高级的 `__atomic_*` 系列函数，它们比 `__sync_*` 提供更精细的内存模型控制：
### **示例函数：**
| 函数名                                        | 描述                                                                       |
|-----------------------------------------------|----------------------------------------------------------------------------|
| `__atomic_fetch_add(ptr, val, memorder)`      | 原子加法，支持自定义内存顺序（如 `__ATOMIC_SEQ_CST`、`__ATOMIC_RELAXED`）。|
| `__atomic_compare_exchange(ptr, ... , order)` | 原子比较并交换，支持不同内存顺序控制。                                     |

---

## **总结**
1. **旧版函数 (`__sync_*`)：** 简单易用，但控制能力较弱（隐式内存顺序为 `seq_cst`）。
2. **新版函数 (`__atomic_*`)：** 提供更灵活的内存模型控制和跨平台兼容性，适合复杂场景。
3. **C++11 标准库 (`<atomic>`)：** 更现代和推荐的解决方案，特别适合用户态编程。

**建议：**
- 若开发面向新架构的软件或希望代码更具可移植性，应优先使用 `std::atomic` 或 `__atomic_*` 系列。

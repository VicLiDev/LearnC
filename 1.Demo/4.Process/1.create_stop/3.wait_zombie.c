/*
 * 如果一个子进程结束的时候,它的父进程正在调用 wait 函数,子进程会直接消失,而退出
 * 代码则通过 wait 函数传递给父进程。但是,如果子进程结束的时候,父进程并没有调用
 * wait,它退出时返回的相关信息——譬如它是否正常结束,以及它的退出值——会直接丢失掉。
 * 在这种情况下,子进程死亡的时候会转化为一个僵尸进程。
 * 
 * 假设,一个进程创建了一个子进程,进行了另外一些计算,然后调用了 wait 。如果子进程
 * 还没有结束,这个进程会在 wait 调用中阻塞,直到子进程结束。如果子进程在父进程调用
 * wait 之前结束,子进程会变成一个僵尸进程。当父进程调用 wait ,僵尸子进程的结束状态
 * 被提取出来,子进程被删除,并且 wait 函数立刻返回。
 *
 * 如果父进程不清理子进程会如何?它们会作为僵尸进程,一直被保留在系统中。代码里的
 * 程序在产生一个立刻结束的子进程之后然后休眠十秒钟退出而不清理子进程,在这十秒钟
 * 里,子进程作为一个僵尸进程存在.当主进程退出后,子进程被交给init进程,init进程会将
 * 此僵尸进程清理掉.
 */

#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
int main ()
{
	pid_t child_pid;
	/* 创建一个子进程 */
	child_pid = fork ();
	if (child_pid > 0) {
		/*这是父进程。休眠十秒钟。 */
		sleep (10);
	}
	else {
	/*这是子进程。立刻退出。 */
		exit (0);
	}
	return 0;
}
